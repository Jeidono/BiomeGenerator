<html>
  <head>
    <title>Tree Generation</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: rgb(251, 222, 0);
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
	<script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from './build/controls/OrbitControls.js';
    import { FirstPersonControls } from './build/controls/FirstPersonControls.js';
    import { OBJLoader } from './build/controls/OBJLoader.js';
    import { GUI } from './build/controls/lil-gui.module.min.js';
    import { MTLLoader } from './build/controls/MTLLoader.js';
    import {PLYLoader} from './build/controls/PLYLoader.js';
    import { Lensflare, LensflareElement } from './build/controls/Lensflare.js';

    //creating scene
    var scene = new THREE.Scene( );
    var ratio = window.innerWidth/window.innerHeight;

    //camera
    var camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
    camera.position.set(0,0,15);
	  camera.lookAt(0,0,1);

    // renderer
    var renderer = new THREE.WebGLRenderer( );
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement );
  
		//controls for camera
		/*var controls = new FirstPersonControls(camera, renderer.domElement);

		var MyUpdateLoop = function(){
		controls.update(1);
		renderer.render(scene,camera);
		requestAnimationFrame(MyUpdateLoop);
		};*/

  var controls = new OrbitControls( camera, renderer.domElement );
  var MyUpdateLoop = function ( )
  {
    renderer.render(scene,camera);
    controls.update();
    requestAnimationFrame(MyUpdateLoop);

  };

  requestAnimationFrame(MyUpdateLoop);

  var MyResize = function ( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width,height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
    renderer.render(scene,camera);
  };

  window.addEventListener('resize', MyResize);


//create light
var light = new THREE.SpotLight(0xE6E6C7, 1, 1000);
light.position.set(-55, 75, -55);

scene.add(light);

var light2 = new THREE.SpotLight(0xE6E6C7, 1, 300);
light2.position.set(90, 6, 90);

scene.add(light2);


//adding the Sun
const geometry = new THREE.SphereGeometry( 15, 32, 16 ); 
const material = new THREE.MeshStandardMaterial( { 
  color: 0xE6E6C7 ,
  emissive: 0xFBDE00,
  emissiveIntensity: 1

} );
const sun = new THREE.Mesh( geometry, material ); 
scene.add( sun );
sun.position.set(-50, 75, -50); // Adjust position as needed

// Creating lighting affect for sun
var canvas = document.createElement('canvas');
canvas.width = 365;
canvas.height = 365;

var context = canvas.getContext('2d');

var gradient = context.createRadialGradient(
    canvas.width / 2,
    canvas.height / 2,
    0,
    canvas.width / 2,
    canvas.height / 2,
    canvas.width / 2
);
gradient.addColorStop(0, 'rgba(255, 165, 255, 1)');
gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.5)');
gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.2)');
gradient.addColorStop(0.4, 'rgba(255, 255, 0, 0.05)');
gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');

context.fillStyle = gradient;
context.fillRect(0, 0, canvas.width, canvas.height);

var texture = new THREE.Texture(canvas);
texture.needsUpdate = true;

var sunMaterial = new THREE.SpriteMaterial({
    map: texture, 
    transparent: true, 
    blending: THREE.AdditiveBlending
});

var sprite = new THREE.Sprite(sunMaterial);
sprite.scale.set(70, 70, 1); // Adjust size as needed
scene.add(sprite);
sprite.position.copy(sun.position);



// Create a grass plane
const grassTexture = new THREE.TextureLoader().load('../../Assets/grass.jpg');
const grassGeometry = new THREE.PlaneGeometry(10, 10);
const grassMaterial = new THREE.MeshBasicMaterial({ map: grassTexture, side: THREE.DoubleSide });
const numRows = 12;
const numCols = 12;
const planeSize = 10;


for (let row = 0; row < numRows; row++) {
    for (let col = 0; col < numCols; col++) {
        const xPos = col * (planeSize) - (numCols * (planeSize)) / 2;
        const zPos = row * (planeSize) - (numRows * (planeSize)) / 2;

        const grassPlane = new THREE.Mesh(grassGeometry, grassMaterial);
        grassPlane.position.set(xPos + 10, -2.01, zPos+ 10);
        grassPlane.rotation.x = -Math.PI / 2;
        scene.add(grassPlane);
    }
}


//loading in different tree types
var trees = [];
var n = 150;

const objLoader = new OBJLoader();
const mtlLoader = new MTLLoader();
const plyLoader = new PLYLoader();

  //generate position for trees
  function generatePosition(trees, size, gap, yPosition){
    var maxAttempts = 10000000000;
    var attempts = 0;
    
    while (attempts < maxAttempts){
      var position = new THREE.Vector3(
        (Math.random() - 0.5) * size,
        yPosition,
        (Math.random() - 0.5) * size
      );

      var collides = trees.some(trees => trees.geometry 
      && position.distanceTo(trees.position) <=
    trees.geometry.parameters.width + gap);
      if(!collides) {
        return position;
      }
      attempts++;
    }
    return new THREE.Vector3(0, yPosition, 0);
  }

  //loading in Trees with material
  function loadTreeModel (treeModel, treeMTL) {
    return new Promise((resolve, reject) => {
      mtlLoader.load(treeMTL, (treeMaterial) => {
        treeMaterial.preload();
        objLoader.setMaterials(treeMaterial).load(treeModel, 
        (root) => {
          resolve(root);
        }, undefined, reject);
      });
    });
  }

    //creating multiple different trees
    function addTrees()
    {
      for(i = 0; i < trees.length; i++){
        scene.remove(trees[i]);
      }
      trees = [];

      for(var i = 0; i < n; i++){
        var treeModel;
        var treeMTL;
        var rand = Math.random();

        if (rand < 1/5) {
          treeModel = '../../Assets/Trees/Tree.obj';
          treeMTL = '../../Assets/Trees/Tree2.obj.mtl';
        } else if(rand < 2/5){
          treeModel = '../../Assets/Trees/Tree2.obj';
          treeMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }
         else if(rand < 3/5) {
          treeModel = '../../Assets/Trees/tree3.obj';
          treeMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if (rand < 4/5){
          treeModel = '../../Assets/Trees/appleTree.obj';
          treeMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else{
          treeModel = '../../Assets/Trees/orangeTree.obj';
          treeMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }

        loadTreeModel(treeModel, treeMTL).then((root) =>{

          //adjust rotation
          root.rotation.y = Math.random() *  Math.PI;

          //adjust gap
          var bbox = new THREE.Box3().setFromObject(root);
          var width = bbox.max.x - bbox.min.x;
          root.userData.width = width;

          root.position.copy(generatePosition(trees, 100, 75, -6.5));  //trees, size, gap, yPosition
          //Adjust y-position
          var height = bbox.max.y - bbox.min.y;
          root.position.y += height / 2;
          
          scene.add(root);
          trees.push(root);
        });

      }
    }
    addTrees();




    //add bushes and other decorative assets into the scene
    var bushes = [];
    var a = 300;

    function addBushes()
    {
      for(i = 0; i < bushes.length; i++){
        scene.remove(bushes[i]);
      }
      bushes = [];

      for(var i = 0; i < a; i++){
        var bushModel;
        var bushMTL;
        var rand = Math.random();

        if (rand < 1/5) {
          bushModel = '../../Assets/Bushes and Foilage/Bush1.obj';
          bushMTL = '../../Assets/Trees/Tree2.obj.mtl';
        } else if(rand < 2/5){
          bushModel = '../../Assets/Bushes and Foilage/Bushs2.obj';
          bushMTL = '../../Assets/Trees/Tree2.obj.mtl';
        } else if(rand < 3/5) {
          bushModel = '../../Assets/Bushes and Foilage/treeStump.obj';
          bushMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 4/5){
          bushModel = '../../Assets/Bushes and Foilage/rocks.obj';
          bushMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else{
          bushModel = '../../Assets/Bushes and Foilage/log.obj';
          bushMTL = '../../Assets/Trees/Tree2.obj.mtl';      
        }

        loadTreeModel(bushModel, bushMTL).then((root) =>{

          //adjust rotation
          root.rotation.y = Math.random() *  Math.PI;

          //adjust gap
          var bbox = new THREE.Box3().setFromObject(root);
          var width = bbox.max.x - bbox.min.x;
          root.userData.width = width;

          root.position.copy(generatePosition(bushes, 100, 75, -2.5));  //bushes, size, gap, yPosition
          //Adjust y-position
          var height = bbox.max.y - bbox.min.y;
          root.position.y += height / 2;
          
          scene.add(root);
          bushes.push(root);
        });

      }
    }

    addBushes();

    //add grass assets into the scene
    var grass = [];
    var g = 500;

    function addGrass()
    {
      for(i = 0; i < grass.length; i++){
        scene.remove(grass[i]);
      }
      bushes = [];

      for(var i = 0; i < g; i++){
        var grassModel;
        var grassMTL;
        var rand = Math.random();

        if (rand < 1/12) {
          grassModel = '../../Assets/Grass/grass1.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        } else if(rand < 2/12){
          grassModel = '../../Assets/Grass/grass2.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        } else if(rand < 3/12) {
          grassModel = '../../Assets/Grass/grass3.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 4/12){
          grassModel = '../../Assets/Grass/rock1.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 5/12){
          grassModel = '../../Assets/Grass/rock2.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 6/12){
          grassModel = '../../Assets/Grass/rock3.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 7/12){
          grassModel = '../../Assets/Grass/rock4.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 8/12){
          grassModel = '../../Assets/Grass/bShrooms.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 9/12){
          grassModel = '../../Assets/Grass/rShroom.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 10/12){
          grassModel = '../../Assets/Grass/flower1.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }else if(rand < 11/12){
          grassModel = '../../Assets/Grass/flower2.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';
        }
        
        
        
        else{
          grassModel = '../../Assets/Grass/flower3.obj';
          grassMTL = '../../Assets/Trees/Tree2.obj.mtl';      
        }

        loadTreeModel(grassModel, grassMTL).then((root) =>{

          //adjust rotation
          root.rotation.y = Math.random() *  Math.PI;

          //adjust gap
          var bbox = new THREE.Box3().setFromObject(root);
          var width = bbox.max.x - bbox.min.x;
          root.userData.width = width;

          root.position.copy(generatePosition(bushes, 100, 0, -2.4));  //bushes, size, gap, yPosition
          //Adjust y-position
          var height = bbox.max.y - bbox.min.y;
          root.position.y += height / 2;
          
          scene.add(root);
          grass.push(root);
        });

      }
    }

    addGrass();




    // Add the sky 
    var skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    var skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide });
    var sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);


    // adding the clouds
    /*const cloudModel = '../../Assets/cloud.obj';
    objLoader.load (cloudModel, (cloud) => {
      const cloudMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.6});
      cloud.traverse((child)=> {
        if (child instanceof THREE.Mesh){
          child.material = cloudMaterial;
        }
      })
      cloud.scale.set(50, 50, 100);
      cloud.position.set(0, 50, 0);
      scene.add(cloud);
    });*/
    
 
      // Function to generate random positions for animals
      function generateAnimalPosition(size, yPosition) {
        return new THREE.Vector3(
          (Math.random() - 0.5) * size,
          yPosition,
          (Math.random() - 0.5) * size
        );
      }

      // Load animal models and place them randomly
      function addAnimalModel(animalModel, scale, yPosition) {
        objLoader.load(animalModel, (animal) => {
          animal.scale.set(scale, scale, scale);
          animal.position.copy(generateAnimalPosition(100, yPosition));
          scene.add(animal);
        });
      }

      // Add different animals to the scene
      const birdModel = '../../Assets/Animal/bird.obj';
      const catModel = '../../Assets/Animal/cat.obj';
      const squirrelModel = '../../Assets/Animal/squirrel.obj';
      const chickModel = '../../Assets/Animal/chick.obj';

// Add birds x10
for (let i = 0; i < 10; i++) {
  addAnimalModelWithMaterial(birdModel, 0.05, -2);
}

// Add squirrels x10
for (let i = 0; i < 10; i++) {
  addAnimalModelWithMaterial(squirrelModel, 0.005, -2);
}

// Add chicks x5
for (let i = 0; i < 5; i++) {
  addAnimalModelWithMaterial(chickModel, 0.5, -2);
}
      

      //Path rendering
      function generateRandomCircularPath(radius, segments) {
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * (radius + Math.random() * 5); // Adding some randomness
                const z = Math.sin(angle) * (radius + Math.random() * 5); // Adding some randomness
                points.push(new THREE.Vector3(x, -2, z));
            }
            return points;
        }

        const radius = 30;
        const segments = 50;
        const pathPoints = generateRandomCircularPath(radius, segments);

    const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
        const pathMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const pathLine = new THREE.Line(pathGeometry, pathMaterial);
        scene.add(pathLine);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();





    </script>
  </body>
</html>
