<html>
  <head>
    <title>Tree Generation</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: lightblue;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
	<script type="module">

    import * as THREE from 'three';4
    import { OrbitControls } from './build/controls/OrbitControls.js';
    import { OBJLoader } from './build/controls/OBJLoader.js';

    //creating scene
    var scene = new THREE.Scene( );
    var ratio = window.innerWidth/window.innerHeight;

    //camera
    var camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
    camera.position.set(0,0,15);
	  camera.lookAt(0,0,1);

    // renderer
    var renderer = new THREE.WebGLRenderer( );
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement );
  
//controls for camera
  var controls = new OrbitControls( camera, renderer.domElement );
  var MyUpdateLoop = function ( )
  {
    renderer.render(scene,camera);
    controls.update();
    requestAnimationFrame(MyUpdateLoop);

  };



  requestAnimationFrame(MyUpdateLoop);

  var MyResize = function ( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width,height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
    renderer.render(scene,camera);
  };

  window.addEventListener('resize', MyResize);
  var cubes = [];
  var n = 300;

//load in trees
const objLoader = new OBJLoader();
objLoader.load('../../Assets/Trees/baretreeWithHole.obj', '../../Assets/Trees/chunkyTree.obj', (root) => {
  var material = new THREE.MeshBasicMaterial();
  material.color= new THREE.Color(0.8, 0.8, 0.8, 0,8);
  material.wireframe = true;
  //material.shininess = 100;
  root.traverse((child) => {
    if(child instanceof THREE.Mesh) {
      child.material = material;
    }
  });
  scene.add(root);
});

  //generate position for trees

  function generatePosition(cubes, size, gap, yPosition){
    var maxAttempts = 1000;
    var attempts = 0;
    
    while (attempts < maxAttempts){
      var position = new THREE.Vector3(
        (Math.random() - 0.5) * size,
        yPosition,
        (Math.random() - 0.5) * size
      );

      var collides = cubes.some(cubes => position.distanceTo(cubes.position) <= cubes.geometry.parameters.width + gap);

      if(!collides) {
        return position;
      }
      attempts++;
    }
    return new THREE.Vector3(0, yPosition, 0);
  }

    //creating multiple different cubes
    function addCubes()
    {
      for(var i = 0; i < n; i++){
      
      
      
      var material_cube = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff});
      material_cube.wireframe=true;
      var geometry_cube = new THREE.BoxGeometry(1,1,1);

      cubes[i] = new THREE.Mesh(geometry_cube, material_cube);

      cubes[i].position.copy(generatePosition(cubes, 100, geometry_cube.parameters.width, 0));

      scene.add(cubes[i]); 

      }

    }

    addCubes();

    </script>
  </body>
</html>
